"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fieldHelpers_1 = require("./fieldHelpers");
// TODO:v5: Remove
const recurseDataGeneratorsWorkaroundFieldByType = new Map();
function makeExtendSchemaPlugin(generator, uniqueId = String(Math.random()).substr(2)) {
    return (builder, schemaOptions) => {
        // Add stuff to the schema
        builder.hook("build", build => {
            const { graphql: { GraphQLEnumType, GraphQLInputObjectType, GraphQLObjectType }, } = build;
            const { typeDefs, resolvers = {} } = typeof generator === "function"
                ? generator(build, schemaOptions)
                : generator;
            if (!typeDefs || typeDefs.kind !== "Document") {
                throw new Error("The first argument to makeExtendSchemaPlugin must be generated by the `gql` helper");
            }
            const typeExtensions = {
                GraphQLInputObjectType: {},
                GraphQLObjectType: {},
            };
            const newTypes = [];
            typeDefs.definitions.forEach(definition => {
                if (definition.kind === "EnumTypeDefinition") {
                    newTypes.push({
                        type: GraphQLEnumType,
                        definition,
                    });
                }
                else if (definition.kind === "ObjectTypeExtension") {
                    const name = getName(definition.name);
                    if (!typeExtensions.GraphQLObjectType[name]) {
                        typeExtensions.GraphQLObjectType[name] = [];
                    }
                    typeExtensions.GraphQLObjectType[name].push(definition);
                }
                else if (definition.kind === "InputObjectTypeExtension") {
                    const name = getName(definition.name);
                    if (!typeExtensions.GraphQLInputObjectType[name]) {
                        typeExtensions.GraphQLInputObjectType[name] = [];
                    }
                    typeExtensions.GraphQLInputObjectType[name].push(definition);
                }
                else if (definition.kind === "ObjectTypeDefinition") {
                    newTypes.push({
                        type: GraphQLObjectType,
                        definition,
                    });
                }
                else if (definition.kind === "InputObjectTypeDefinition") {
                    newTypes.push({
                        type: GraphQLInputObjectType,
                        definition,
                    });
                }
                else {
                    if (definition.kind === "TypeExtensionDefinition") {
                        throw new Error(`You appear to be using a GraphQL version prior to v0.12.0 which has different syntax for schema extensions (e.g. 'TypeExtensionDefinition' instead of 'ObjectTypeExtension'). Sadly makeExtendSchemaPlugin does not support versions of graphql prior to 0.12.0, please update your version of graphql.`);
                    }
                    throw new Error(`Unexpected '${definition.kind}' definition; we were expecting 'GraphQLEnumType', 'ObjectTypeExtension', 'InputObjectTypeExtension', 'ObjectTypeDefinition' or 'InputObjectTypeDefinition', i.e. something like 'extend type Foo { ... }'`);
                }
            });
            return build.extend(build, {
                [`ExtendSchemaPlugin_${uniqueId}_typeExtensions`]: typeExtensions,
                [`ExtendSchemaPlugin_${uniqueId}_newTypes`]: newTypes,
                [`ExtendSchemaPlugin_${uniqueId}_resolvers`]: resolvers,
            });
        });
        builder.hook("init", (_, build, _context) => {
            const { newWithHooks, [`ExtendSchemaPlugin_${uniqueId}_newTypes`]: newTypes, [`ExtendSchemaPlugin_${uniqueId}_resolvers`]: resolvers, graphql: { GraphQLEnumType, GraphQLObjectType, GraphQLInputObjectType }, } = build;
            newTypes.forEach(({ type, definition }) => {
                if (type === GraphQLEnumType) {
                    // https://graphql.org/graphql-js/type/#graphqlenumtype
                    const name = getName(definition.name);
                    const description = getDescription(definition.description);
                    const directives = getDirectives(definition.directives);
                    const relevantResolver = resolvers[name] || {};
                    const values = definition.values.reduce((memo, value) => {
                        const valueName = getName(value.name);
                        const valueDescription = getDescription(value.description);
                        const valueDirectives = getDirectives(value.directives);
                        // Value cannot be expressed via SDL, so we grab the value from the resolvers instead.
                        // resolvers = {
                        //   MyEnum: {
                        //     MY_ENUM_VALUE1: 'value1',
                        //     MY_ENUM_VALUE2: 'value2',
                        //   }
                        // }
                        // Ref: https://github.com/graphql/graphql-js/issues/525#issuecomment-255834625
                        const valueValue = relevantResolver[valueName] !== undefined
                            ? relevantResolver[valueName]
                            : valueName;
                        const valueDeprecationReason = valueDirectives.deprecated && valueDirectives.deprecated.reason;
                        return Object.assign({}, memo, { [valueName]: {
                                value: valueValue,
                                deprecationReason: valueDeprecationReason,
                                description: valueDescription,
                                directives: valueDirectives,
                            } });
                    }, {});
                    const scope = Object.assign({ directives }, (directives.scope || {}));
                    newWithHooks(type, { name, values, description }, scope);
                }
                else if (type === GraphQLObjectType) {
                    // https://graphql.org/graphql-js/type/#graphqlobjecttype
                    const name = getName(definition.name);
                    const description = getDescription(definition.description);
                    const interfaces = getInterfaces(definition.interfaces, build);
                    const directives = getDirectives(definition.directives);
                    const scope = Object.assign({ __origin: `makeExtendSchemaPlugin`, directives }, (directives.scope || {}));
                    newWithHooks(type, Object.assign({ name,
                        interfaces, fields: (fieldsContext) => getFields(fieldsContext.Self, definition.fields, resolvers, fieldsContext, build) }, (description
                        ? {
                            description,
                        }
                        : null)), scope);
                }
                else if (type === GraphQLInputObjectType) {
                    // https://graphql.org/graphql-js/type/#graphqlinputobjecttype
                    const name = getName(definition.name);
                    const description = getDescription(definition.description);
                    const directives = getDirectives(definition.directives);
                    const scope = Object.assign({ __origin: `makeExtendSchemaPlugin`, directives }, (directives.scope || {}));
                    newWithHooks(type, Object.assign({ name, fields: ({ Self }) => getInputFields(Self, definition.fields, build) }, (description
                        ? {
                            description,
                        }
                        : null)), scope);
                }
                else {
                    throw new Error(`We have no code to build an object of type '${type}'; it should not have reached this area of the code.`);
                }
            });
            return _;
        });
        builder.hook("GraphQLObjectType:fields", (fields, build, context) => {
            const { extend, [`ExtendSchemaPlugin_${uniqueId}_typeExtensions`]: typeExtensions, [`ExtendSchemaPlugin_${uniqueId}_resolvers`]: resolvers, } = build;
            const { Self } = context;
            if (typeExtensions.GraphQLObjectType[Self.name]) {
                const newFields = typeExtensions.GraphQLObjectType[Self.name].reduce((memo, extension) => {
                    const moreFields = getFields(Self, extension.fields, resolvers, context, build);
                    return extend(memo, moreFields);
                }, {});
                return extend(fields, newFields);
            }
            else {
                return fields;
            }
        });
        builder.hook("GraphQLInputObjectType:fields", (fields, build, context) => {
            const { extend, [`ExtendSchemaPlugin_${uniqueId}_typeExtensions`]: typeExtensions, } = build;
            const { Self } = context;
            if (typeExtensions.GraphQLInputObjectType[Self.name]) {
                const newFields = typeExtensions.GraphQLInputObjectType[Self.name].reduce((memo, extension) => {
                    const moreFields = getInputFields(Self, extension.fields, build);
                    return extend(memo, moreFields);
                }, {});
                return extend(fields, newFields);
            }
            else {
                return fields;
            }
        });
    };
}
exports.default = makeExtendSchemaPlugin;
function getName(name) {
    if (name && name.kind === "Name" && name.value) {
        return name.value;
    }
    throw new Error("Could not extract name from AST");
}
function getDescription(desc) {
    if (!desc) {
        return null;
    }
    else if (desc.kind === "StringValue") {
        return desc.value;
    }
    else {
        throw new Error(`AST issue, we weren't expecting a description of kind '${desc.kind}' - PRs welcome!`);
    }
}
function getType(type, build) {
    if (type.kind === "NamedType") {
        const Type = build.getTypeByName(getName(type.name));
        if (!Type) {
            throw new Error(`Could not find type named '${getName(type.name)}'.`);
        }
        return Type;
    }
    else if (type.kind === "NonNullType") {
        return new build.graphql.GraphQLNonNull(getType(type.type, build));
    }
    else if (type.kind === "ListType") {
        return new build.graphql.GraphQLList(getType(type.type, build));
    }
    else {
        throw new Error(`We don't support AST type definition of kind '${type.kind}' yet... PRs welcome!`);
    }
}
function getInterfaces(interfaces, _build) {
    if (interfaces.length) {
        throw new Error(`We don't support interfaces via makeExtendSchemaPlugin yet; PRs welcome!`);
    }
    return [];
}
function getValue(value) {
    if (value.kind === "BooleanValue") {
        return !!value.value;
    }
    else if (value.kind === "StringValue") {
        return value.value;
    }
    else if (value.kind === "IntValue") {
        return parseInt(value.value, 10);
    }
    else if (value.kind === "FloatValue") {
        return parseFloat(value.value);
    }
    else if (value.kind === "NullValue") {
        return null;
    }
    else if (value.kind === "ListValue") {
        return value.values.map(getValue);
    }
    else if (value.kind === "GraphileEmbed") {
        // RAW!
        return value.value;
    }
    else {
        throw new Error(`Value kind '${value.kind}' not supported yet. PRs welcome!`);
    }
}
function getDirectives(directives) {
    return (directives || []).reduce((directivesList, directive) => {
        if (directive.kind === "Directive") {
            const name = getName(directive.name);
            const value = (directive.arguments || []).reduce((argumentValues, arg) => {
                if (arg.kind === "Argument") {
                    const argName = getName(arg.name);
                    const argValue = getValue(arg.value);
                    if (argumentValues[name]) {
                        throw new Error(`Argument '${argName}' of directive '${name}' must only be used once.`);
                    }
                    argumentValues[argName] = argValue;
                }
                else {
                    throw new Error(`Unexpected '${arg.kind}', we were expecting 'Argument'`);
                }
                return argumentValues;
            }, {});
            if (directivesList[name]) {
                throw new Error(`Directive '${name}' must only be used once per field.`);
            }
            directivesList[name] = value;
        }
        else {
            throw new Error(`Unexpected '${directive.kind}', we were expecting 'Directive'`);
        }
        return directivesList;
    }, {});
}
function getArguments(args, build) {
    if (args && args.length) {
        return args.reduce((memo, arg) => {
            if (arg.kind === "InputValueDefinition") {
                const name = getName(arg.name);
                const type = getType(arg.type, build);
                const description = getDescription(arg.description);
                let defaultValue;
                if (arg.defaultValue) {
                    defaultValue = getValue(arg.defaultValue);
                }
                memo[name] = Object.assign({ type }, (defaultValue ? { defaultValue } : null), (description ? { description } : null));
            }
            else {
                throw new Error(`Unexpected '${arg.kind}', we were expecting an 'InputValueDefinition'`);
            }
            return memo;
        }, {});
    }
    return {};
}
function getFields(SelfGeneric, fields, resolvers, { fieldWithHooks, }, build) {
    const scopeByType = build.scopeByType || new Map();
    if (!build.graphql.isNamedType(SelfGeneric)) {
        throw new Error("getFields only supports named types");
    }
    const Self = SelfGeneric;
    const { pgSql: sql } = build;
    function augmentResolver(resolver, fieldContext, type) {
        let got = false;
        let val;
        const getRecurseDataGeneratorsWorkaroundField = () => {
            if (!got) {
                got = true;
                const namedType = build.graphql.getNamedType(type);
                val = recurseDataGeneratorsWorkaroundFieldByType.get(namedType);
            }
            return val;
        };
        const newResolver = async (parent, args, context, resolveInfo) => {
            const graphileHelpers = fieldHelpers_1.makeFieldHelpers(build, fieldContext, context, resolveInfo);
            const result = await resolver(parent, args, context, Object.assign({}, resolveInfo, { graphile: graphileHelpers }), graphileHelpers);
            const recurseDataGeneratorsWorkaroundField = getRecurseDataGeneratorsWorkaroundField();
            if (result != null &&
                !result.data &&
                recurseDataGeneratorsWorkaroundField) {
                return Object.assign({}, result, { data: result[recurseDataGeneratorsWorkaroundField] });
            }
            return result;
        };
        return newResolver;
    }
    if (fields && fields.length) {
        return fields.reduce((memo, field) => {
            if (field.kind === "FieldDefinition") {
                const description = getDescription(field.description);
                const fieldName = getName(field.name);
                const args = getArguments(field.arguments, build);
                const type = getType(field.type, build);
                const nullableType = build.graphql.getNullableType(type);
                const namedType = build.graphql.getNamedType(type);
                const typeScope = scopeByType.get(namedType) || {};
                const directives = getDirectives(field.directives);
                const scope = Object.assign({}, (typeScope.pgIntrospection &&
                    typeScope.pgIntrospection.kind === "class"
                    ? {
                        pgFieldIntrospection: typeScope.pgIntrospection,
                    }
                    : null), (typeScope.isPgRowConnectionType && typeScope.pgIntrospection
                    ? {
                        isPgFieldConnection: true,
                        pgFieldIntrospection: typeScope.pgIntrospection,
                    }
                    : null), { fieldDirectives: directives }, (directives.scope || {}));
                const deprecationReason = directives.deprecated && directives.deprecated.reason;
                const functionToResolveObject = (functionOrResolveObject) => typeof functionOrResolveObject === "function"
                    ? { resolve: functionOrResolveObject }
                    : functionOrResolveObject;
                const isConnection = !!scope.isPgFieldConnection;
                const isListType = nullableType !== namedType &&
                    nullableType.constructor === build.graphql.GraphQLList;
                const table = scope.pgFieldIntrospection &&
                    scope.pgFieldIntrospection.kind === "class"
                    ? scope.pgFieldIntrospection
                    : null;
                const generateImplicitResolverIfPossible = () => {
                    if (directives.pgQuery && table) {
                        return (data, _args, _resolveContext, resolveInfo) => {
                            const safeAlias = build.getSafeAliasFromResolveInfo(resolveInfo);
                            const liveRecord = resolveInfo.rootValue && resolveInfo.rootValue.liveRecord;
                            if (isConnection) {
                                return build.pgAddStartEndCursor(data[safeAlias]);
                            }
                            else if (isListType) {
                                const records = data[safeAlias];
                                if (table && liveRecord) {
                                    records.forEach((r) => r && liveRecord("pg", table, r.__identifiers));
                                }
                                return records;
                            }
                            else {
                                const record = data[safeAlias];
                                if (record && liveRecord && table) {
                                    liveRecord("pg", table, record.__identifiers);
                                }
                                return record;
                            }
                        };
                    }
                    return null;
                };
                /*
                 * We accept a resolver function directly, or an object which can
                 * define 'resolve', 'subscribe' and other relevant methods.
                 */
                const possibleResolver = resolvers[Self.name]
                    ? resolvers[Self.name][fieldName]
                    : null;
                const resolver = possibleResolver &&
                    (typeof possibleResolver === "object" ||
                        typeof possibleResolver === "function")
                    ? possibleResolver
                    : generateImplicitResolverIfPossible();
                const rawResolversSpec = resolver
                    ? functionToResolveObject(resolver)
                    : null;
                if (directives.recurseDataGenerators) {
                    if (!recurseDataGeneratorsWorkaroundFieldByType.get(Self)) {
                        recurseDataGeneratorsWorkaroundFieldByType.set(Self, fieldName);
                    }
                    // tslint:disable-next-line no-console
                    console.warn("DEPRECATION: `recurseDataGenerators` is misleading, please use `pgField` instead");
                    if (!directives.pgField) {
                        directives.pgField = directives.recurseDataGenerators;
                    }
                }
                const fieldSpecGenerator = (fieldContext) => {
                    const { pgIntrospection } = fieldContext.scope;
                    // @requires directive: pulls down necessary columns from table.
                    //
                    //   e.g. `@requires(columns: ["id", "name"])`
                    //
                    if (directives.requires && pgIntrospection.kind === "class") {
                        // tslint:disable-next-line no-shadowed-variable
                        const table = pgIntrospection;
                        if (Array.isArray(directives.requires.columns)) {
                            const attrs = table.attributes.filter(attr => directives.requires.columns.indexOf(attr.name) >= 0);
                            const fieldNames = attrs.map(attr => build.inflection.column(attr));
                            const ReturnTypes = attrs.map(attr => build.pgGetGqlTypeByTypeIdAndModifier(attr.typeId, attr.typeModifier) || build.graphql.GraphQLString);
                            fieldContext.addDataGenerator((parsedResolveInfoFragment) => ({
                                pgQuery: (queryBuilder) => {
                                    attrs.forEach((attr, i) => {
                                        const columnFieldName = fieldNames[i];
                                        const ReturnType = ReturnTypes[i];
                                        queryBuilder.select(build.pgGetSelectValueForFieldAndTypeAndModifier(ReturnType, fieldContext, parsedResolveInfoFragment, sql.fragment `(${queryBuilder.getTableAlias()}.${sql.identifier(attr.name)})`, // The brackets are necessary to stop the parser getting confused, ref: https://www.postgresql.org/docs/9.6/static/rowtypes.html#ROWTYPES-ACCESSING
                                        attr.type, attr.typeModifier), columnFieldName);
                                    });
                                },
                            }));
                        }
                        else {
                            throw new Error(`@requires(columns: ["...", ...]) directive called with invalid arguments`);
                        }
                    }
                    if (directives.pgQuery && table) {
                        fieldContext.addDataGenerator((parsedResolveInfoFragment) => {
                            return {
                                pgQuery: (queryBuilder) => {
                                    queryBuilder.select(() => {
                                        const resolveData = fieldContext.getDataFromParsedResolveInfoFragment(parsedResolveInfoFragment, namedType);
                                        const tableAlias = sql.identifier(Symbol());
                                        const query = build.pgQueryFromResolveData(directives.pgQuery.source, tableAlias, resolveData, {
                                            withPagination: isConnection,
                                            withPaginationAsFields: false,
                                            asJsonAggregate: isListType && !isConnection,
                                            asJson: !isConnection,
                                            addNullCase: !isConnection,
                                        }, (innerQueryBuilder) => {
                                            innerQueryBuilder.parentQueryBuilder = queryBuilder;
                                            if (build.options.subscriptions &&
                                                table.primaryKeyConstraint) {
                                                innerQueryBuilder.selectIdentifiers(table);
                                            }
                                            if (typeof directives.pgQuery.withQueryBuilder ===
                                                "function") {
                                                directives.pgQuery.withQueryBuilder(innerQueryBuilder, parsedResolveInfoFragment.args);
                                            }
                                        }, queryBuilder.context, queryBuilder.rootValue);
                                        return sql.fragment `(${query})`;
                                    }, build.getSafeAliasFromAlias(parsedResolveInfoFragment.alias));
                                },
                            };
                        });
                    }
                    const resolversSpec = rawResolversSpec
                        ? Object.keys(rawResolversSpec).reduce((newResolversSpec, key) => {
                            if (typeof rawResolversSpec[key] === "function") {
                                newResolversSpec[key] = augmentResolver(rawResolversSpec[key], fieldContext, type);
                            }
                            return newResolversSpec;
                        }, {})
                        : {};
                    return Object.assign({ type,
                        args }, (deprecationReason
                        ? {
                            deprecationReason,
                        }
                        : null), (description
                        ? {
                            description,
                        }
                        : null), resolversSpec);
                };
                if (directives.pgField) {
                    return build.extend(memo, {
                        [fieldName]: build.pgField(build, fieldWithHooks, fieldName, fieldSpecGenerator, scope, false),
                    });
                }
                else {
                    return build.extend(memo, {
                        [fieldName]: fieldWithHooks(fieldName, fieldSpecGenerator, scope),
                    });
                }
            }
            else {
                throw new Error(`AST issue: expected 'FieldDefinition', instead received '${field.kind}'`);
            }
        }, {});
    }
    return {};
}
function getInputFields(_Self, fields, build) {
    if (fields && fields.length) {
        return fields.reduce((memo, field) => {
            if (field.kind === "InputValueDefinition") {
                const description = getDescription(field.description);
                const fieldName = getName(field.name);
                const type = getType(field.type, build);
                memo[fieldName] = Object.assign({ type }, (description
                    ? {
                        description,
                    }
                    : null));
            }
            else {
                throw new Error(`AST issue: expected 'FieldDefinition', instead received '${field.kind}'`);
            }
            return memo;
        }, {});
    }
    return {};
}
//# sourceMappingURL=makeExtendSchemaPlugin.js.map