{"version":3,"sources":["../../src/plugins/PgTablesPlugin.js"],"names":["base64","str","Buffer","from","String","toString","hasNonNullKey","row","Array","isArray","__identifiers","every","i","k","hasOwnProperty","PgTablesPlugin","builder","pgForbidSetofFunctionsToReturnNull","subscriptions","handleNullRow","_identifiers","identifiers","hook","_","build","getNodeIdForTypeAndIdentifiers","nodeIdFieldName","newWithHooks","getSafeAliasFromResolveInfo","pgSql","sql","pgIntrospectionResultsByKind","introspectionResultsByKind","getTypeByName","pgGetGqlTypeByTypeIdAndModifier","pgGetGqlInputTypeByTypeIdAndModifier","pgRegisterGqlTypeByTypeId","pgRegisterGqlInputTypeByTypeId","pg2GqlMapper","gql2pg","graphql","GraphQLObjectType","GraphQLNonNull","GraphQLID","GraphQLList","GraphQLInputObjectType","inflection","describePgEntity","sqlCommentByAddingTags","pgField","nullableIf","condition","Type","Cursor","class","forEach","table","tablePgType","type","Error","arrayTablePgType","arrayType","primaryKeyConstraint","primaryKeys","keyAttributes","attributes","tableTypeName","tableType","shouldHaveNodeId","isSelectable","namespace","length","TableType","TablePatchType","TableBaseInputType","id","cb","description","name","interfaces","builtin","fields","addDataGeneratorForField","Self","pgQuery","queryBuilder","selectIdentifiers","resolve","data","__origin","pgIntrospection","isPgRowType","isPgCompoundType","isPgCompositeType","pgCreateInputFields","pgPatchInputFields","pgBaseInputFields","inputType","isInputType","pgAddSubfield","fieldName","attrName","pgType","spec","typeModifier","patchType","isPgPatch","baseInputType","isPgBaseInput","map","unmap","obj","modifier","fieldLookup","attr2sql","attr","column","inputField","v","fragment","identifier","namespaceName","null","join","EdgeType","edge","fieldWithHooks","cursor","addDataGenerator","usesCursor","__cursor","JSON","stringify","isCursorField","node","_args","resolveContext","resolveInfo","safeAlias","record","liveRecord","rootValue","withQueryBuilder","isEdgeType","isPgRowEdgeType","nodeType","PageInfo","connection","recurseDataGeneratorsForField","nodes","entry","edges","_context","hoistCursor","pageInfo","isConnectionType","isPgRowConnectionType","edgeType","_set","RelevantTableInputType"],"mappings":"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","sourcesContent":["// @flow\nimport type { Plugin } from \"graphile-build\";\nconst base64 = str => Buffer.from(String(str)).toString(\"base64\");\n\nconst hasNonNullKey = row => {\n  if (\n    Array.isArray(row.__identifiers) &&\n    row.__identifiers.every(i => i != null)\n  ) {\n    return true;\n  }\n  for (const k in row) {\n    if (row.hasOwnProperty(k)) {\n      if ((k[0] !== \"_\" || k[1] !== \"_\") && row[k] !== null) {\n        return true;\n      }\n    }\n  }\n  return false;\n};\n\nexport default (function PgTablesPlugin(\n  builder,\n  { pgForbidSetofFunctionsToReturnNull = false, subscriptions = false }\n) {\n  const handleNullRow = pgForbidSetofFunctionsToReturnNull\n    ? (row, _identifiers) => row\n    : (row, identifiers) => {\n        if ((identifiers && hasNonNullKey(identifiers)) || hasNonNullKey(row)) {\n          return row;\n        } else {\n          return null;\n        }\n      };\n\n  builder.hook(\n    \"init\",\n    (_, build) => {\n      const {\n        getNodeIdForTypeAndIdentifiers,\n        nodeIdFieldName,\n        newWithHooks,\n        getSafeAliasFromResolveInfo,\n        pgSql: sql,\n        pgIntrospectionResultsByKind: introspectionResultsByKind,\n        getTypeByName,\n        pgGetGqlTypeByTypeIdAndModifier,\n        pgGetGqlInputTypeByTypeIdAndModifier,\n        pgRegisterGqlTypeByTypeId,\n        pgRegisterGqlInputTypeByTypeId,\n        pg2GqlMapper,\n        gql2pg,\n        graphql: {\n          GraphQLObjectType,\n          GraphQLNonNull,\n          GraphQLID,\n          GraphQLList,\n          GraphQLInputObjectType,\n        },\n        inflection,\n        describePgEntity,\n        sqlCommentByAddingTags,\n        pgField,\n      } = build;\n\n      const nullableIf = (condition, Type) =>\n        condition ? Type : new GraphQLNonNull(Type);\n      const Cursor = getTypeByName(\"Cursor\");\n\n      introspectionResultsByKind.class.forEach(table => {\n        const tablePgType = table.type;\n        if (!tablePgType) {\n          throw new Error(\"Could not determine the type for this table\");\n        }\n        const arrayTablePgType = tablePgType.arrayType;\n        const primaryKeyConstraint = table.primaryKeyConstraint;\n        const primaryKeys =\n          primaryKeyConstraint && primaryKeyConstraint.keyAttributes;\n        const attributes = table.attributes;\n        const tableTypeName = inflection.tableType(table);\n        const shouldHaveNodeId: boolean =\n          nodeIdFieldName &&\n          table.isSelectable &&\n          table.namespace &&\n          primaryKeys &&\n          primaryKeys.length\n            ? true\n            : false;\n        let TableType;\n        let TablePatchType;\n        let TableBaseInputType;\n        pgRegisterGqlTypeByTypeId(\n          tablePgType.id,\n          cb => {\n            if (TableType) {\n              return TableType;\n            }\n            if (pg2GqlMapper[tablePgType.id]) {\n              // Already handled\n              throw new Error(\n                `Register was called but there's already a mapper in place for '${\n                  tablePgType.id\n                }'!`\n              );\n            }\n            TableType = newWithHooks(\n              GraphQLObjectType,\n              {\n                description: table.description || tablePgType.description,\n                name: tableTypeName,\n                interfaces: () => {\n                  if (shouldHaveNodeId) {\n                    return [getTypeByName(inflection.builtin(\"Node\"))];\n                  } else {\n                    return [];\n                  }\n                },\n                fields: ({ addDataGeneratorForField, Self }) => {\n                  const fields = {};\n                  if (shouldHaveNodeId) {\n                    // Enable nodeId interface\n                    addDataGeneratorForField(nodeIdFieldName, () => {\n                      return {\n                        pgQuery: queryBuilder => {\n                          queryBuilder.selectIdentifiers(table);\n                        },\n                      };\n                    });\n                    fields[nodeIdFieldName] = {\n                      description:\n                        \"A globally unique identifier. Can be used in various places throughout the system to identify this single value.\",\n                      type: new GraphQLNonNull(GraphQLID),\n                      resolve(data) {\n                        return (\n                          data.__identifiers &&\n                          getNodeIdForTypeAndIdentifiers(\n                            Self,\n                            ...data.__identifiers\n                          )\n                        );\n                      },\n                    };\n                  }\n                  return fields;\n                },\n              },\n              {\n                __origin: `Adding table type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable, // TODO:v5: remove - typo\n                isPgCompositeType: !table.isSelectable,\n              }\n            );\n            cb(TableType);\n            const pgCreateInputFields = {};\n            const pgPatchInputFields = {};\n            const pgBaseInputFields = {};\n            newWithHooks(\n              GraphQLInputObjectType,\n              {\n                description: `An input for mutations affecting \\`${tableTypeName}\\``,\n                name: inflection.inputType(TableType),\n              },\n              {\n                __origin: `Adding table input type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                pgIntrospection: table,\n                isInputType: true,\n                isPgRowType: table.isSelectable,\n                isPgCompoundType: !table.isSelectable,\n                pgAddSubfield(fieldName, attrName, pgType, spec, typeModifier) {\n                  pgCreateInputFields[fieldName] = {\n                    name: attrName,\n                    type: pgType,\n                    typeModifier,\n                  };\n                  return spec;\n                },\n              },\n              true // If no fields, skip type automatically\n            );\n\n            if (table.isSelectable) {\n              // XXX: these don't belong here; but we have to keep them here\n              // because third-party code depends on `getTypeByName` to find\n              // them; so we have to register them ahead of time. A better\n              // approach is to use the modifier to specify the type you need,\n              // 'patch' or 'base', so they can be registered just in time.\n              TablePatchType = newWithHooks(\n                GraphQLInputObjectType,\n                {\n                  description: `Represents an update to a \\`${tableTypeName}\\`. Fields that are set will be updated.`,\n                  name: inflection.patchType(TableType),\n                },\n                {\n                  __origin: `Adding table patch type for ${describePgEntity(\n                    table\n                  )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                    table,\n                    {\n                      name: \"newNameHere\",\n                    }\n                  )}`,\n                  pgIntrospection: table,\n                  isPgRowType: table.isSelectable,\n                  isPgCompoundType: !table.isSelectable,\n                  isPgPatch: true,\n                  pgAddSubfield(\n                    fieldName,\n                    attrName,\n                    pgType,\n                    spec,\n                    typeModifier\n                  ) {\n                    pgPatchInputFields[fieldName] = {\n                      name: attrName,\n                      type: pgType,\n                      typeModifier,\n                    };\n                    return spec;\n                  },\n                },\n                true // Safe to skip this if no fields support updating\n              );\n              TableBaseInputType = newWithHooks(\n                GraphQLInputObjectType,\n                {\n                  description: `An input representation of \\`${tableTypeName}\\` with nullable fields.`,\n                  name: inflection.baseInputType(TableType),\n                },\n                {\n                  __origin: `Adding table base input type for ${describePgEntity(\n                    table\n                  )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                    table,\n                    {\n                      name: \"newNameHere\",\n                    }\n                  )}`,\n                  pgIntrospection: table,\n                  isPgRowType: table.isSelectable,\n                  isPgCompoundType: !table.isSelectable,\n                  isPgBaseInput: true,\n                  pgAddSubfield(\n                    fieldName,\n                    attrName,\n                    pgType,\n                    spec,\n                    typeModifier\n                  ) {\n                    pgBaseInputFields[fieldName] = {\n                      name: attrName,\n                      type: pgType,\n                      typeModifier,\n                    };\n                    return spec;\n                  },\n                }\n              );\n            }\n\n            pg2GqlMapper[tablePgType.id] = {\n              map: _ => _,\n              unmap: (obj, modifier) => {\n                let fieldLookup;\n                if (modifier === \"patch\") {\n                  fieldLookup = pgPatchInputFields;\n                } else if (modifier === \"base\") {\n                  fieldLookup = pgBaseInputFields;\n                } else {\n                  fieldLookup = pgCreateInputFields;\n                }\n\n                const attr2sql = attr => {\n                  // TODO: this should use `fieldInput[*].name` to find the attribute\n                  const fieldName = inflection.column(attr);\n                  const inputField = fieldLookup[fieldName];\n                  const v = obj[fieldName];\n                  if (inputField && v != null) {\n                    const { type, typeModifier } = inputField;\n                    return sql.fragment`${gql2pg(\n                      v,\n                      type,\n                      typeModifier\n                    )}::${sql.identifier(type.namespaceName, type.name)}`;\n                  } else {\n                    return sql.null; // TODO: return default instead.\n                  }\n                };\n\n                return sql.fragment`row(${sql.join(\n                  attributes.map(attr2sql),\n                  \",\"\n                )})::${sql.identifier(\n                  tablePgType.namespaceName,\n                  tablePgType.name\n                )}`;\n              },\n            };\n\n            const EdgeType = newWithHooks(\n              GraphQLObjectType,\n              {\n                description: `A \\`${tableTypeName}\\` edge in the connection.`,\n                name: inflection.edge(TableType.name),\n                fields: ({ fieldWithHooks }) => {\n                  return {\n                    cursor: fieldWithHooks(\n                      \"cursor\",\n                      ({ addDataGenerator }) => {\n                        addDataGenerator(() => ({\n                          usesCursor: [true],\n                          pgQuery: queryBuilder => {\n                            if (primaryKeys) {\n                              queryBuilder.selectIdentifiers(table);\n                            }\n                          },\n                        }));\n                        return {\n                          description: \"A cursor for use in pagination.\",\n                          type: Cursor,\n                          resolve(data) {\n                            return (\n                              data.__cursor &&\n                              base64(JSON.stringify(data.__cursor))\n                            );\n                          },\n                        };\n                      },\n                      {\n                        isCursorField: true,\n                      }\n                    ),\n                    node: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"node\",\n                      {\n                        description: `The \\`${tableTypeName}\\` at the end of the edge.`,\n                        type: nullableIf(\n                          !pgForbidSetofFunctionsToReturnNull,\n                          TableType\n                        ),\n                        resolve(data, _args, resolveContext, resolveInfo) {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          const record = handleNullRow(\n                            data[safeAlias],\n                            data.__identifiers\n                          );\n                          const liveRecord =\n                            resolveInfo.rootValue &&\n                            resolveInfo.rootValue.liveRecord;\n                          if (\n                            record &&\n                            primaryKeys &&\n                            liveRecord &&\n                            data.__identifiers\n                          ) {\n                            liveRecord(\"pg\", table, data.__identifiers);\n                          }\n                          return record;\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        withQueryBuilder: queryBuilder => {\n                          if (subscriptions) {\n                            queryBuilder.selectIdentifiers(table);\n                          }\n                        },\n                      }\n                    ),\n                  };\n                },\n              },\n              {\n                __origin: `Adding table edge type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                isEdgeType: true,\n                isPgRowEdgeType: true,\n                nodeType: TableType,\n                pgIntrospection: table,\n              }\n            );\n            const PageInfo = getTypeByName(inflection.builtin(\"PageInfo\"));\n\n            /*const ConnectionType = */\n            newWithHooks(\n              GraphQLObjectType,\n              {\n                description: `A connection to a list of \\`${tableTypeName}\\` values.`,\n                name: inflection.connection(TableType.name),\n                fields: ({ recurseDataGeneratorsForField, fieldWithHooks }) => {\n                  recurseDataGeneratorsForField(\"pageInfo\", true);\n                  return {\n                    nodes: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"nodes\",\n                      {\n                        description: `A list of \\`${tableTypeName}\\` objects.`,\n                        type: new GraphQLNonNull(\n                          new GraphQLList(\n                            nullableIf(\n                              !pgForbidSetofFunctionsToReturnNull,\n                              TableType\n                            )\n                          )\n                        ),\n                        resolve(data, _args, resolveContext, resolveInfo) {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          const liveRecord =\n                            resolveInfo.rootValue &&\n                            resolveInfo.rootValue.liveRecord;\n                          return data.data.map(entry => {\n                            const record = handleNullRow(\n                              entry[safeAlias],\n                              entry[safeAlias].__identifiers\n                            );\n                            if (\n                              record &&\n                              liveRecord &&\n                              primaryKeys &&\n                              entry[safeAlias].__identifiers\n                            ) {\n                              liveRecord(\n                                \"pg\",\n                                table,\n                                entry[safeAlias].__identifiers\n                              );\n                            }\n\n                            return record;\n                          });\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        withQueryBuilder: queryBuilder => {\n                          if (subscriptions) {\n                            queryBuilder.selectIdentifiers(table);\n                          }\n                        },\n                      }\n                    ),\n                    edges: pgField(\n                      build,\n                      fieldWithHooks,\n                      \"edges\",\n                      {\n                        description: `A list of edges which contains the \\`${tableTypeName}\\` and cursor to aid in pagination.`,\n                        type: new GraphQLNonNull(\n                          new GraphQLList(new GraphQLNonNull(EdgeType))\n                        ),\n                        resolve(data, _args, _context, resolveInfo) {\n                          const safeAlias = getSafeAliasFromResolveInfo(\n                            resolveInfo\n                          );\n                          return data.data.map(entry => ({\n                            ...entry,\n                            ...entry[safeAlias],\n                          }));\n                        },\n                      },\n                      {},\n                      false,\n                      {\n                        hoistCursor: true,\n                      }\n                    ),\n                    pageInfo: PageInfo && {\n                      description: \"Information to aid in pagination.\",\n                      type: new GraphQLNonNull(PageInfo),\n                      resolve(data) {\n                        return data;\n                      },\n                    },\n                  };\n                },\n              },\n              {\n                __origin: `Adding table connection type for ${describePgEntity(\n                  table\n                )}. You can rename the table's GraphQL type via:\\n\\n  ${sqlCommentByAddingTags(\n                  table,\n                  {\n                    name: \"newNameHere\",\n                  }\n                )}`,\n                isConnectionType: true,\n                isPgRowConnectionType: true,\n                edgeType: EdgeType,\n                nodeType: TableType,\n                pgIntrospection: table,\n              }\n            );\n          },\n          true\n        );\n        pgRegisterGqlInputTypeByTypeId(\n          tablePgType.id,\n          (_set, modifier) => {\n            // This must come first, it triggers creation of all the types\n            const TableType = pgGetGqlTypeByTypeIdAndModifier(\n              tablePgType.id,\n              null\n            );\n            // This must come after the pgGetGqlTypeByTypeIdAndModifier call\n            if (modifier === \"patch\") {\n              // TODO: v5: move the definition from above down here\n              return TablePatchType;\n            }\n            if (modifier === \"base\") {\n              // TODO: v5: move the definition from above down here\n              return TableBaseInputType;\n            }\n            if (TableType) {\n              return getTypeByName(inflection.inputType(TableType));\n            }\n            return null;\n          },\n          true\n        );\n\n        if (arrayTablePgType) {\n          // Note: these do not return\n          //\n          // `new GraphQLList(new GraphQLNonNull(...))`\n          //\n          // because it's possible to return null entries from postgresql\n          // functions. We should probably add a flag to instead export\n          // the non-null version as that's more typical.\n          pgRegisterGqlTypeByTypeId(\n            arrayTablePgType.id,\n            () => {\n              const TableType = pgGetGqlTypeByTypeIdAndModifier(\n                tablePgType.id,\n                null\n              );\n              return new GraphQLList(TableType);\n            },\n            true\n          );\n          pgRegisterGqlInputTypeByTypeId(\n            arrayTablePgType.id,\n            (_set, modifier) => {\n              const RelevantTableInputType = pgGetGqlInputTypeByTypeIdAndModifier(\n                tablePgType.id,\n                modifier\n              );\n              if (RelevantTableInputType) {\n                return new GraphQLList(RelevantTableInputType);\n              }\n            },\n            true\n          );\n        }\n      });\n      return _;\n    },\n    [\"PgTables\"],\n    [],\n    [\"PgTypes\"]\n  );\n}: Plugin);\n"],"file":"PgTablesPlugin.js"}