{"version":3,"sources":["../src/Live.js"],"names":["DEBOUNCE_DURATION","MONITOR_THROTTLE_DURATION","Math","max","parseInt","process","env","LIVE_THROTTLE","LiveSource","subscribeCollection","_callback","_collectionIdentifier","_predicate","subscribeRecord","_recordIdentifier","LiveProvider","constructor","namespace","sources","registerSource","source","push","collectionIdentifierIsValid","recordIdentifierIsValid","LiveMonitor","providers","extraRootValue","released","subscriptionReleasersByCounter","changeCallback","changeCounter","liveConditionsByCounter","handleChange","Error","bind","leading","trailing","_reallyHandleChange","onChange","resetBefore","currentCounter","oldCounters","Object","keys","filter","n","oldCounter","releaser","release","cancel","Infinity","cb","counter","String","changeRootValue","liveCollection","liveRecord","liveConditions","console","warn","callback","setImmediate","collectionIdentifier","predicate","provider","length","recordIdentifier","LiveCoordinator","subscribe","registerProvider","getMonitor","_parent","_args","_context","_info","monitor","liveAbort","e","iterator","throw","makeAsyncIteratorFromMonitor","onClose"],"mappings":";;;;;;;;AAEA;;AAEA;;;;AAHA;AAWA,MAAMA,iBAAiB,GAAG,EAA1B;AAEA,MAAMC,yBAAyB,GAAGC,IAAI,CAACC,GAAL,CAChCH,iBAAiB,GAAG,CADY,EAEhCI,QAAQ,CAACC,OAAO,CAACC,GAAR,CAAYC,aAAZ,IAA6B,EAA9B,EAAkC,EAAlC,CAAR,IAAiD,GAFjB,CAAlC;AAKA;;;;;AAIO,MAAMC,UAAN,CAAiB;AACtBC,EAAAA,mBAAmB,CACjBC,SADiB,EAEjBC,qBAFiB,EAGjBC,UAHiB,EAIY;AAC7B,WAAO,IAAP;AACD;;AAEDC,EAAAA,eAAe,CACbH,SADa,EAEbC,qBAFa,EAGbG,iBAHa,EAIgB;AAC7B,WAAO,IAAP;AACD;;AAfqB;AAkBxB;;;;;;;;;;AAMO,MAAMC,YAAN,CAAmB;AAIxBC,EAAAA,WAAW,CAACC,SAAD,EAAoB;AAC7B,SAAKA,SAAL,GAAiBA,SAAjB;AACA,SAAKC,OAAL,GAAe,EAAf;AACD;;AAEDC,EAAAA,cAAc,CAACC,MAAD,EAAqB;AACjC,SAAKF,OAAL,CAAaG,IAAb,CAAkBD,MAAlB;AACD;;AAEDE,EAAAA,2BAA2B,CAACX,qBAAD,EAAsC;AAC/D,WAAO,KAAP;AACD;;AAEDY,EAAAA,uBAAuB,CACrBZ,qBADqB,EAErBG,iBAFqB,EAGZ;AACT,WAAO,KAAP;AACD;;AAtBuB;AAyB1B;;;;;;;;AAIO,MAAMU,WAAN,CAAkB;AAWvBR,EAAAA,WAAW,CACTS,SADS,EAETC,cAFS,EAGT;AACA,SAAKA,cAAL,GAAsBA,cAAtB;AACA,SAAKC,QAAL,GAAgB,KAAhB;AACA,SAAKF,SAAL,GAAiBA,SAAjB;AACA,SAAKG,8BAAL,GAAsC,EAAtC;AACA,SAAKC,cAAL,GAAsB,IAAtB;AACA,SAAKC,aAAL,GAAqB,CAArB;AACA,SAAKC,uBAAL,GAA+B,EAA/B;;AACA,QAAI,CAAC,KAAKC,YAAV,EAAwB;AACtB,YAAM,IAAIC,KAAJ,CAAU,iCAAV,CAAN;AACD;;AACD,SAAKD,YAAL,GAAoB,sBAClB,KAAKA,YAAL,CAAkBE,IAAlB,CAAuB,IAAvB,CADkB,EAElBlC,iBAFkB,EAGlB;AACEmC,MAAAA,OAAO,EAAE,KADX;AAEEC,MAAAA,QAAQ,EAAE;AAFZ,KAHkB,CAApB;;AAQA,QAAI,CAAC,KAAKC,mBAAV,EAA+B;AAC7B,YAAM,IAAIJ,KAAJ,CAAU,iCAAV,CAAN;AACD;;AACD,SAAKI,mBAAL,GAA2B,sBACzB,KAAKA,mBAAL,CAAyBH,IAAzB,CAA8B,IAA9B,CADyB,EAEzBjC,yBAAyB,GAAGD,iBAFH,EAGzB;AACEmC,MAAAA,OAAO,EAAE,IADX;AAEEC,MAAAA,QAAQ,EAAE;AAFZ,KAHyB,CAA3B;AAQA,SAAKE,QAAL,GAAgB,KAAKA,QAAL,CAAcJ,IAAd,CAAmB,IAAnB,CAAhB;AACD;;AAEDK,EAAAA,WAAW,CAACC,cAAD,EAAyB;AAClC;AACA;AACE,YAAMC,WAAW,GAAGC,MAAM,CAACC,IAAP,CAClB,KAAKf,8BADa,EAElBgB,MAFkB,CAEXC,CAAC,IAAIzC,QAAQ,CAACyC,CAAD,EAAI,EAAJ,CAAR,GAAkBL,cAFZ,CAApB;;AAGA,WAAK,MAAMM,UAAX,IAAyBL,WAAzB,EAAsC;AACpC,aAAK,MAAMM,QAAX,IAAuB,KAAKnB,8BAAL,CACrBkB,UADqB,CAAvB,EAEG;AACDC,UAAAA,QAAQ;AACT;;AACD,eAAO,KAAKnB,8BAAL,CAAoCkB,UAApC,CAAP;AACD;AACF,KAdiC,CAelC;;AACA;AACE,YAAML,WAAW,GAAGC,MAAM,CAACC,IAAP,CAAY,KAAKZ,uBAAjB,EAA0Ca,MAA1C,CAClBC,CAAC,IAAIzC,QAAQ,CAACyC,CAAD,EAAI,EAAJ,CAAR,GAAkBL,cADL,CAApB;;AAGA,WAAK,MAAMM,UAAX,IAAyBL,WAAzB,EAAsC;AACpC,eAAO,KAAKV,uBAAL,CAA6Be,UAA7B,CAAP;AACD;AACF;AACF;;AAEDE,EAAAA,OAAO,GAAG;AACR,QAAI,KAAKhB,YAAT,EAAuB;AACrB,WAAKA,YAAL,CAAkBiB,MAAlB;AACD;;AACD,SAAKjB,YAAL,GAAoB,IAApB;;AACA,QAAI,KAAKK,mBAAT,EAA8B;AAC5B,WAAKA,mBAAL,CAAyBY,MAAzB;AACD;;AACD,SAAKZ,mBAAL,GAA2B,IAA3B;AACA,SAAKE,WAAL,CAAiBW,QAAjB;AACA,SAAKzB,SAAL,GAAiB,EAAjB;AACA,SAAKE,QAAL,GAAgB,IAAhB;AACD,GArFsB,CAuFvB;;;AAEAK,EAAAA,YAAY,GAAG;AACb;;;;;;;AAOA,QAAI,KAAKK,mBAAT,EAA8B;AAC5B,WAAKA,mBAAL;AACD;AACF,GApGsB,CAsGvB;;;AAEAA,EAAAA,mBAAmB,GAAG;AACpB;AACA,QAAI,KAAKR,cAAT,EAAyB;AACvB;AACA,YAAMsB,EAAE,GAAG,KAAKtB,cAAhB;AACA,YAAMuB,OAAO,GAAG,KAAKtB,aAAL,EAAhB;AACA;;;;;;;;AAOA,WAAKF,8BAAL,CAAoCyB,MAAM,CAACD,OAAD,CAA1C,IAAuD,EAAvD;AACA,WAAKrB,uBAAL,CAA6BsB,MAAM,CAACD,OAAD,CAAnC,IAAgD,EAAhD;AACA,YAAME,eAAe,GAAG,EACtB,GAAG,KAAK5B,cADc;AAEtB0B,QAAAA,OAFsB;AAGtBG,QAAAA,cAAc,EAAE,KAAKA,cAAL,CAAoBrB,IAApB,CAAyB,IAAzB,EAA+BkB,OAA/B,CAHM;AAItBI,QAAAA,UAAU,EAAE,KAAKA,UAAL,CAAgBtB,IAAhB,CAAqB,IAArB,EAA2BkB,OAA3B,CAJU;AAKtBK,QAAAA,cAAc,EAAE,KAAK1B,uBAAL,CAA6BsB,MAAM,CAACD,OAAD,CAAnC,CALM;AAMtBJ,QAAAA,OAAO,EAAE,MAAM;AACb;AACA,eAAKT,WAAL,CAAiBa,OAAjB;AACD;AATqB,OAAxB;AAWAD,MAAAA,EAAE,CAACG,eAAD,CAAF;AACD,KAzBD,MAyBO;AACL;AACAI,MAAAA,OAAO,CAACC,IAAR,CAAa,2CAAb;AACD;AACF,GAvIsB,CAyIvB;;;AAEArB,EAAAA,QAAQ,CAACsB,QAAD,EAAuB;AAC7B,QAAI,KAAKjC,QAAT,EAAmB;AACjB,YAAM,IAAIM,KAAJ,CAAU,4BAAV,CAAN;AACD;;AACD,QAAI,KAAKJ,cAAT,EAAyB;AACvB,YAAM,IAAII,KAAJ,CAAU,gCAAV,CAAN;AACD,KAN4B,CAO7B;;;AACA,SAAKJ,cAAL,GAAsB+B,QAAtB;;AACA,QAAI,KAAK5B,YAAT,EAAuB;AACrB6B,MAAAA,YAAY,CAAC,KAAK7B,YAAN,CAAZ;AACD;;AACD,WAAO,MAAM;AACX,UAAI,KAAKH,cAAL,KAAwB+B,QAA5B,EAAsC;AACpC,aAAK/B,cAAL,GAAsB,IAAtB;AACD;;AACD,WAAKmB,OAAL;AACD,KALD;AAMD;;AAEDO,EAAAA,cAAc,CACZH,OADY,EAEZnC,SAFY,EAGZ6C,oBAHY,EAIZC,SAAmC,GAAG,MAAM,IAJhC,EAKZ;AACA,UAAM/B,YAAY,GAAG,KAAKA,YAA1B;;AACA,QAAI,KAAKL,QAAL,IAAiB,CAACK,YAAtB,EAAoC;AAClC;AACD;;AACD,UAAMgC,QAAQ,GAAG,KAAKvC,SAAL,CAAeR,SAAf,CAAjB;AACA,QAAI,CAAC+C,QAAD,IAAaA,QAAQ,CAAC9C,OAAT,CAAiB+C,MAAjB,KAA4B,CAA7C,EAAgD;;AAChD,QAAI,CAACD,QAAQ,CAAC1C,2BAAT,CAAqCwC,oBAArC,CAAL,EAAiE;AAC/D,YAAM,IAAI7B,KAAJ,CACH,uDAAsDhB,SAAU,MAAK6C,oBAAqB,EADvF,CAAN;AAGD;;AACD,SAAK,MAAM1C,MAAX,IAAqB4C,QAAQ,CAAC9C,OAA9B,EAAuC;AACrC,YAAM6B,QAAQ,GAAG3B,MAAM,CAACX,mBAAP,CACfuB,YADe,EAEf8B,oBAFe,EAGfC,SAHe,CAAjB;;AAKA,UAAIhB,QAAJ,EAAc;AACZ,aAAKnB,8BAAL,CAAoCyB,MAAM,CAACD,OAAD,CAA1C,EAAqD/B,IAArD,CAA0D0B,QAA1D;AACD;AACF;AACF;;AAEDS,EAAAA,UAAU,CACRJ,OADQ,EAERnC,SAFQ,EAGR6C,oBAHQ,EAIRI,gBAJQ,EAKR;AACA,UAAMlC,YAAY,GAAG,KAAKA,YAA1B;;AACA,QAAI,KAAKL,QAAL,IAAiB,CAACK,YAAtB,EAAoC;AAClC;AACD,KAJD,CAKA;;;AACA,UAAMgC,QAAQ,GAAG,KAAKvC,SAAL,CAAeR,SAAf,CAAjB;AACA,QAAI,CAAC+C,QAAD,IAAaA,QAAQ,CAAC9C,OAAT,CAAiB+C,MAAjB,KAA4B,CAA7C,EAAgD;;AAChD,QAAI,CAACD,QAAQ,CAAC1C,2BAAT,CAAqCwC,oBAArC,CAAL,EAAiE;AAC/D,YAAM,IAAI7B,KAAJ,CACH,uDAAsDhB,SAAU,MAAK6C,oBAAqB,EADvF,CAAN;AAGD;;AACD,QACE,CAACE,QAAQ,CAACzC,uBAAT,CAAiCuC,oBAAjC,EAAuDI,gBAAvD,CADH,EAEE;AACA,YAAM,IAAIjC,KAAJ,CACH,mDAAkDhB,SAAU,MAAK6C,oBAAqB,EADnF,CAAN;AAGD;;AACD,SAAK,MAAM1C,MAAX,IAAqB4C,QAAQ,CAAC9C,OAA9B,EAAuC;AACrC,YAAM6B,QAAQ,GAAG3B,MAAM,CAACP,eAAP,CACfmB,YADe,EAEf8B,oBAFe,EAGfI,gBAHe,CAAjB;;AAKA,UAAInB,QAAJ,EAAc;AACZ,aAAKnB,8BAAL,CAAoCyB,MAAM,CAACD,OAAD,CAA1C,EAAqD/B,IAArD,CAA0D0B,QAA1D;AACD;AACF;AACF;;AA/NsB;AAkOzB;;;;;;;;;AAKO,MAAMoB,eAAN,CAAsB;AAG3BnD,EAAAA,WAAW,GAAG;AACZ,SAAKS,SAAL,GAAiB,EAAjB;AACA,SAAK2C,SAAL,GAAiB,KAAKA,SAAL,CAAelC,IAAf,CAAoB,IAApB,CAAjB;AACD;;AAEDmC,EAAAA,gBAAgB,CAACL,QAAD,EAAyB;AACvC,UAAM;AAAE/C,MAAAA;AAAF,QAAgB+C,QAAtB;;AACA,QAAI,KAAKvC,SAAL,CAAeR,SAAf,CAAJ,EAA+B;AAC7B,YAAM,IAAIgB,KAAJ,CAAW,aAAYhB,SAAU,+BAAjC,CAAN;AACD;;AACD,SAAKQ,SAAL,CAAeR,SAAf,IAA4B+C,QAA5B;AACD;;AAED7C,EAAAA,cAAc,CAACF,SAAD,EAAoBG,MAApB,EAAwC;AACpD,QAAI,CAAC,KAAKK,SAAL,CAAeR,SAAf,CAAL,EAAgC;AAC9B;AACAyC,MAAAA,OAAO,CAACC,IAAR,CACG,iBAAgB1C,SAAU,4CAD7B;AAGA;AACD;;AACD,SAAKQ,SAAL,CAAeR,SAAf,EAA0BE,cAA1B,CAAyCC,MAAzC;AACD;;AAEDkD,EAAAA,UAAU,CAAC5C,cAAD,EAAsB;AAC9B,WAAO,IAAIF,WAAJ,CAAgB,KAAKC,SAArB,EAAgCC,cAAhC,CAAP;AACD,GA7B0B,CA+B3B;;;AAOA0C,EAAAA,SAAS,CACPG,OADO,EAEPC,KAFO,EAGPC,QAHO,EAIPC,KAJO,EAKP;AACA,UAAMC,OAAO,GAAG,KAAKL,UAAL,CAAgB;AAC9BM,MAAAA,SAAS,EAAEC,CAAC,IAAI;AACd,YAAIC,QAAJ,EAAcA,QAAQ,CAACC,KAAT,CAAeF,CAAf;AACf;AAH6B,KAAhB,CAAhB;AAKA,UAAMC,QAAQ,GAAGE,4BAA4B,CAACL,OAAD,CAA7C;AACA,WAAOG,QAAP;AACD;;AAnD0B;;;;AAsDtB,SAASE,4BAAT,CAAsCL,OAAtC,EAA4D;AACjE,SAAO,sCAAwBA,OAAO,CAACrC,QAAhC,EAA0C;AAC/C2C,IAAAA,OAAO,EAAEjC,OAAO,IAAI;AAClB,UAAIA,OAAJ,EAAaA,OAAO;AACrB;AAH8C,GAA1C,CAAP;AAKD","sourcesContent":["// @flow\n/* eslint-disable flowtype/no-weak-types */\nimport callbackToAsyncIterator from \"./callbackToAsyncIterator\";\nimport type { GraphQLResolveInfo } from \"graphql\";\nimport { throttle } from \"lodash\";\n\ntype SubscriptionReleaser = () => void;\ntype SubscriptionCallback = () => void;\n\ntype Predicate = (record: any) => boolean;\ntype PredicateGenerator = (data: any) => Predicate;\n\nconst DEBOUNCE_DURATION = 25;\n\nconst MONITOR_THROTTLE_DURATION = Math.max(\n  DEBOUNCE_DURATION + 1,\n  parseInt(process.env.LIVE_THROTTLE || \"\", 10) || 500\n);\n\n/*\n * Sources are long-lived (i.e. in \"watch\" mode you just re-use the same one\n * over and over) because there is no release for them\n */\nexport class LiveSource {\n  subscribeCollection(\n    _callback: SubscriptionCallback,\n    _collectionIdentifier: any,\n    _predicate?: Predicate\n  ): SubscriptionReleaser | null {\n    return null;\n  }\n\n  subscribeRecord(\n    _callback: SubscriptionCallback,\n    _collectionIdentifier: any,\n    _recordIdentifier: any\n  ): SubscriptionReleaser | null {\n    return null;\n  }\n}\n\n/*\n * Providers enable a namespace, perform validation, and track the sources used\n * by that namespace within one single schema build. The should not directly use\n * any long-lived features as they do not have an explicit \"release\"/\"close\"\n * command when a new schema is built.\n */\nexport class LiveProvider {\n  sources: Array<LiveSource>;\n  namespace: string;\n\n  constructor(namespace: string) {\n    this.namespace = namespace;\n    this.sources = [];\n  }\n\n  registerSource(source: LiveSource) {\n    this.sources.push(source);\n  }\n\n  collectionIdentifierIsValid(_collectionIdentifier: any): boolean {\n    return false;\n  }\n\n  recordIdentifierIsValid(\n    _collectionIdentifier: any,\n    _recordIdentifier: any\n  ): boolean {\n    return false;\n  }\n}\n\n/*\n * During a single execution of GraphQL (specifically a subscription request),\n * the LiveMonitor tracks the resources viewed and subscribes to updates in them.\n */\nexport class LiveMonitor {\n  released: boolean;\n  providers: { [namespace: string]: LiveProvider };\n  subscriptionReleasersByCounter: {\n    [counter: string]: (() => void)[],\n  };\n  liveConditionsByCounter: { [counter: string]: Array<PredicateGenerator> };\n  changeCallback: ((arg: any) => void) | null;\n  changeCounter: number;\n  extraRootValue: any;\n\n  constructor(\n    providers: { [namespace: string]: LiveProvider },\n    extraRootValue: any\n  ) {\n    this.extraRootValue = extraRootValue;\n    this.released = false;\n    this.providers = providers;\n    this.subscriptionReleasersByCounter = {};\n    this.changeCallback = null;\n    this.changeCounter = 0;\n    this.liveConditionsByCounter = {};\n    if (!this.handleChange) {\n      throw new Error(\"This is just to make flow happy\");\n    }\n    this.handleChange = throttle(\n      this.handleChange.bind(this),\n      DEBOUNCE_DURATION,\n      {\n        leading: false,\n        trailing: true,\n      }\n    );\n    if (!this._reallyHandleChange) {\n      throw new Error(\"This is just to make flow happy\");\n    }\n    this._reallyHandleChange = throttle(\n      this._reallyHandleChange.bind(this),\n      MONITOR_THROTTLE_DURATION - DEBOUNCE_DURATION,\n      {\n        leading: true,\n        trailing: true,\n      }\n    );\n    this.onChange = this.onChange.bind(this);\n  }\n\n  resetBefore(currentCounter: number) {\n    // Clear out of date subscriptionReleasers\n    {\n      const oldCounters = Object.keys(\n        this.subscriptionReleasersByCounter\n      ).filter(n => parseInt(n, 10) < currentCounter);\n      for (const oldCounter of oldCounters) {\n        for (const releaser of this.subscriptionReleasersByCounter[\n          oldCounter\n        ]) {\n          releaser();\n        }\n        delete this.subscriptionReleasersByCounter[oldCounter];\n      }\n    }\n    // Clear out of date liveConditions\n    {\n      const oldCounters = Object.keys(this.liveConditionsByCounter).filter(\n        n => parseInt(n, 10) < currentCounter\n      );\n      for (const oldCounter of oldCounters) {\n        delete this.liveConditionsByCounter[oldCounter];\n      }\n    }\n  }\n\n  release() {\n    if (this.handleChange) {\n      this.handleChange.cancel();\n    }\n    this.handleChange = null;\n    if (this._reallyHandleChange) {\n      this._reallyHandleChange.cancel();\n    }\n    this._reallyHandleChange = null;\n    this.resetBefore(Infinity);\n    this.providers = {};\n    this.released = true;\n  }\n\n  // Tell Flow that we're okay with overwriting this\n  handleChange: (() => void) | null;\n  handleChange() {\n    /* This function is throttled to ~25ms (see constructor); it's purpose is\n     * to bundle up all the changes that occur in a small window into the same\n     * handle change flow, so _reallyHandleChange doesn't get called twice in\n     * quick succession. _reallyHandleChange is then further throttled with a\n     * larger window, BUT it triggers on both leading and trailing edge,\n     * whereas this only triggers on the trailing edge.\n     */\n    if (this._reallyHandleChange) {\n      this._reallyHandleChange();\n    }\n  }\n\n  // Tell Flow that we're okay with overwriting this\n  _reallyHandleChange: (() => void) | null;\n  _reallyHandleChange() {\n    // This function is throttled to MONITOR_THROTTLE_DURATION (see constructor)\n    if (this.changeCallback) {\n      // Convince Flow this won't suddenly become null\n      const cb = this.changeCallback;\n      const counter = this.changeCounter++;\n      /*\n       * In live queries we need to know when the current result set has\n       * finished being calculated so that we know we've received all the\n       * liveRecord / liveCollection calls and can release the out of date\n       * ones. To achieve this, we use a custom `subscribe` function which\n       * calls `rootValue.release()` once the result set has been calculated.\n       */\n      this.subscriptionReleasersByCounter[String(counter)] = [];\n      this.liveConditionsByCounter[String(counter)] = [];\n      const changeRootValue = {\n        ...this.extraRootValue,\n        counter,\n        liveCollection: this.liveCollection.bind(this, counter),\n        liveRecord: this.liveRecord.bind(this, counter),\n        liveConditions: this.liveConditionsByCounter[String(counter)],\n        release: () => {\n          // Despite it's name, this means that the execution has complete, which means we're actually releasing everything *before* this.\n          this.resetBefore(counter);\n        },\n      };\n      cb(changeRootValue);\n    } else {\n      // eslint-disable-next-line no-console\n      console.warn(\"Change occurred, but no-one was listening\");\n    }\n  }\n\n  // Tell Flow that we're okay with overwriting this\n  onChange: (callback: () => void) => void;\n  onChange(callback: () => void) {\n    if (this.released) {\n      throw new Error(\"Monitors cannot be reused.\");\n    }\n    if (this.changeCallback) {\n      throw new Error(\"Already monitoring for changes\");\n    }\n    // Throttle to every 250ms\n    this.changeCallback = callback;\n    if (this.handleChange) {\n      setImmediate(this.handleChange);\n    }\n    return () => {\n      if (this.changeCallback === callback) {\n        this.changeCallback = null;\n      }\n      this.release();\n    };\n  }\n\n  liveCollection(\n    counter: number,\n    namespace: string,\n    collectionIdentifier: any,\n    predicate: (record: any) => boolean = () => true\n  ) {\n    const handleChange = this.handleChange;\n    if (this.released || !handleChange) {\n      return;\n    }\n    const provider = this.providers[namespace];\n    if (!provider || provider.sources.length === 0) return;\n    if (!provider.collectionIdentifierIsValid(collectionIdentifier)) {\n      throw new Error(\n        `Invalid collection identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    for (const source of provider.sources) {\n      const releaser = source.subscribeCollection(\n        handleChange,\n        collectionIdentifier,\n        predicate\n      );\n      if (releaser) {\n        this.subscriptionReleasersByCounter[String(counter)].push(releaser);\n      }\n    }\n  }\n\n  liveRecord(\n    counter: number,\n    namespace: string,\n    collectionIdentifier: any,\n    recordIdentifier: any\n  ) {\n    const handleChange = this.handleChange;\n    if (this.released || !handleChange) {\n      return;\n    }\n    // TODO: if (recordIdentifier == null) {return}\n    const provider = this.providers[namespace];\n    if (!provider || provider.sources.length === 0) return;\n    if (!provider.collectionIdentifierIsValid(collectionIdentifier)) {\n      throw new Error(\n        `Invalid collection identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    if (\n      !provider.recordIdentifierIsValid(collectionIdentifier, recordIdentifier)\n    ) {\n      throw new Error(\n        `Invalid record identifier passed to LiveMonitor[${namespace}]: ${collectionIdentifier}`\n      );\n    }\n    for (const source of provider.sources) {\n      const releaser = source.subscribeRecord(\n        handleChange,\n        collectionIdentifier,\n        recordIdentifier\n      );\n      if (releaser) {\n        this.subscriptionReleasersByCounter[String(counter)].push(releaser);\n      }\n    }\n  }\n}\n\n/*\n * There is one coordinator for each build of the GraphQL schema, it tracks the providers\n * and gives a handy `subscribe` method that can be used for live queries (assuming\n * that the `resolve` is provided the same as in a Query).\n */\nexport class LiveCoordinator {\n  providers: { [namespace: string]: LiveProvider };\n\n  constructor() {\n    this.providers = {};\n    this.subscribe = this.subscribe.bind(this);\n  }\n\n  registerProvider(provider: LiveProvider) {\n    const { namespace } = provider;\n    if (this.providers[namespace]) {\n      throw new Error(`Namespace ${namespace} already registered with Live`);\n    }\n    this.providers[namespace] = provider;\n  }\n\n  registerSource(namespace: string, source: LiveSource) {\n    if (!this.providers[namespace]) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `LiveProvider '${namespace}' is not registered, skipping live source.`\n      );\n      return;\n    }\n    this.providers[namespace].registerSource(source);\n  }\n\n  getMonitor(extraRootValue: any) {\n    return new LiveMonitor(this.providers, extraRootValue);\n  }\n\n  // Tell Flow that we're okay with overwriting this\n  subscribe: (\n    _parent: any,\n    _args: any,\n    context: any,\n    _info: GraphQLResolveInfo\n  ) => any;\n  subscribe(\n    _parent: any,\n    _args: any,\n    _context: any,\n    _info: GraphQLResolveInfo\n  ) {\n    const monitor = this.getMonitor({\n      liveAbort: e => {\n        if (iterator) iterator.throw(e);\n      },\n    });\n    const iterator = makeAsyncIteratorFromMonitor(monitor);\n    return iterator;\n  }\n}\n\nexport function makeAsyncIteratorFromMonitor(monitor: LiveMonitor) {\n  return callbackToAsyncIterator(monitor.onChange, {\n    onClose: release => {\n      if (release) release();\n    },\n  });\n}\n"],"file":"Live.js"}