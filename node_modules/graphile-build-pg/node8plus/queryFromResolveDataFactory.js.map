{"version":3,"sources":["../src/queryFromResolveDataFactory.js"],"names":["identity","_","undefined","queryBuilderOptions","from","fromAlias","resolveData","inOptions","withBuilder","context","rootValue","pgQuery","pgAggregateQuery","pgCursorPrefix","reallyRawCursorPrefix","pgDontUseAsterisk","calculateHasNextPage","calculateHasPreviousPage","usesCursor","explicitlyUsesCursor","preventAsterisk","length","options","useAsterisk","rawCursorPrefix","filter","queryBuilder","QueryBuilder","i","l","generateNextPrevPageSql","sqlQueryAlias","canHaveCursorInWhere","queryHasBefore","queryHasFirst","offset","invert","sqlCommonUnbounded","sql","fragment","getTableExpression","getTableAlias","sqlCommon","buildWhereClause","isForwardOrSymmetric","literal","buildWhereBoundClause","getSelectCursor","blank","value","limit","getFinalLimitAndOffset","getPgCursorPrefix","data","cursorPrefix","map","val","withPagination","withPaginationAsFields","withCursor","selectCursor","orderBy","getOrderByExpressionsAndDirections","expr","isOrderUnique","join","setCursorComparator","cursorValue","isAfter","orderByExpressionsAndDirections","sqlCursors","Array","isArray","whereBound","sqlFilter","sqlExpression","ascending","comparison","Number","sqlOldFilter","null","getOffset","Math","max","Error","query","build","haveFields","getSelectFieldsCount","identifier","Symbol","sqlSummaryAlias","compiledData","upper","queryHasAfter","lower","queryHasZeroLimit","getFinalLimit","first","queryHasLast","last","hasNextPage","getFinalOffset","hasPreviousPage","sqlWith","sqlFrom","fields","push","aggregateQueryBuilder","aggregateJsonBuildObject","onlyJsonField","aggregatesSql","alias","jsonbBuildObject"],"mappings":"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","sourcesContent":["// @flow\nimport QueryBuilder from \"./QueryBuilder\";\nimport type QueryBuilderOptions from \"./QueryBuilder\";\nimport type { RawAlias } from \"./QueryBuilder\";\nimport * as sql from \"pg-sql2\";\nimport type { SQL } from \"pg-sql2\";\nimport type { DataForType } from \"graphile-build\";\nimport isSafeInteger from \"lodash/isSafeInteger\";\nimport assert from \"assert\";\n\n// eslint-disable-next-line flowtype/no-weak-types\ntype GraphQLContext = any;\n\nconst identity = _ => _ !== null && _ !== undefined;\n\n// $FlowFixMe\nexport default (queryBuilderOptions: QueryBuilderOptions = {}) => (\n  from: SQL,\n  fromAlias: ?SQL,\n  resolveData: DataForType,\n  inOptions: {\n    withPagination?: boolean,\n    withPaginationAsFields?: boolean,\n    asJson?: boolean,\n    asJsonAggregate?: boolean,\n    addNullCase?: boolean,\n    addNotDistinctFromNullCase?: boolean,\n    onlyJsonField?: boolean,\n    useAsterisk?: boolean,\n  },\n  // TODO:v5: context is not optional\n  withBuilder?: ((builder: QueryBuilder) => void) | null | void,\n  context?: GraphQLContext = {},\n  rootValue?: any // eslint-disable-line flowtype/no-weak-types\n) => {\n  const {\n    pgQuery,\n    pgAggregateQuery,\n    pgCursorPrefix: reallyRawCursorPrefix,\n    pgDontUseAsterisk,\n    calculateHasNextPage,\n    calculateHasPreviousPage,\n    usesCursor: explicitlyUsesCursor,\n  } = resolveData;\n\n  const preventAsterisk = pgDontUseAsterisk\n    ? pgDontUseAsterisk.length > 0\n    : false;\n  const options = {\n    ...inOptions,\n    // Allow pgDontUseAsterisk to override useAsterisk\n    useAsterisk: inOptions.useAsterisk && !preventAsterisk,\n  };\n\n  const usesCursor: boolean =\n    (explicitlyUsesCursor && explicitlyUsesCursor.length > 0) ||\n    (calculateHasNextPage && calculateHasNextPage.length > 0) ||\n    (calculateHasPreviousPage && calculateHasPreviousPage.length > 0) ||\n    false;\n  const rawCursorPrefix =\n    reallyRawCursorPrefix && reallyRawCursorPrefix.filter(identity);\n\n  // $FlowFixMe\n  const queryBuilder = new QueryBuilder(\n    // $FlowFixMe\n    queryBuilderOptions,\n    context,\n    rootValue\n  );\n  queryBuilder.from(from, fromAlias ? fromAlias : undefined);\n\n  if (withBuilder) {\n    withBuilder(queryBuilder);\n  }\n  if (pgQuery) {\n    for (let i = 0, l = pgQuery.length; i < l; i++) {\n      pgQuery[i](queryBuilder, resolveData);\n    }\n  }\n\n  function generateNextPrevPageSql(\n    sqlQueryAlias,\n    canHaveCursorInWhere,\n    queryHasBefore,\n    queryHasFirst,\n    offset = 0,\n    invert = false\n  ) {\n    /*\n     * Strap in, 'coz this function gets hairy!\n     *\n     * The point of this function is to return SQL which will resolve to a\n     * boolean true/false depending on whether or not there is a (invert ?\n     * \"previous\" : \"next\") page.\n     *\n     * Connections have before, after, first, last and offset.\n     * - Users are forbidden from setting both first and last.\n     * - Users are forbidden from setting both offset and last.\n     *\n     * Further there are two main modes of paginating, one works by adding a\n     * where clause (this is preferred, but is not always possible, and is\n     * indicated by `canHaveCursorInWhere === true`) and the other works using\n     * standard LIMIT/OFFSET SQL pagination (and is indicated by\n     * `canHaveCursorInWhere === false`).\n     *\n     * The following diagram shows a full collection of records, #, starting at\n     * START and ending at END. The key after, before, offset, first and last\n     * variables are shown. One thing not show is that it's possible to have\n     * fewer records between before and after than requested by first or last.\n     * Another detail not clearly show is that if there is no `after` then\n     * `START` is used, similarly if there is no `before` then `END` is used.\n     *\n     *   #################################################### < collection\n     *   ^      ^<-offset->^<-first->^      ^<-last->^      ^\n     *   |      |          |         |      |        |      |\n     *   |      |          +---------+      +--------+      |\n     *   |      |          |  DATA1           DATA2  |      |\n     *   |      |          |                         |      |\n     *   |      |          |                         |      |\n     *   |      |          +-------------------------+      |\n     *   |      |                     DATA3          |      |\n     *   |    after                                before   |\n     *   |                                                  |\n     * START                                               END\n     *\n     * We want one of the three DATA blocks:\n     *\n     * - If `first` is set, then we want DATA1.\n     * - If `last` is set then we want DATA2.\n     * - If neither is set then we want DATA3.\n     *\n     * (Remember: you cannot set both `first` and `last` at the same time.)\n     *\n     * When invert === false:\n     *\n     *   Note that both DATA2 and DATA3 end at the same point, and we only care\n     *   if there's data *after* the relevant DATA block, so really we only\n     *   care if the query specified `first` (`queryHasFirst`) which makes\n     *   things complex (ending at the end of DATA1), otherwise we can use\n     *   `before` as the bound (end of DATA2/DATA3).\n     *\n     * When invert === true:\n     *\n     *   Similarly, DATA1 and DATA3 start at the same point, and we're going\n     *   backwards so we only care if there's data *before* the DATA block, so\n     *   really we just need to know if the query set `last` or not, but since\n     *   this is inverted we call it `queryHasFirst`.\n     *\n     * When `invert` is false we're calculating `hasNextPage`, when true we're\n     * calculating `hasPreviousPage`.\n     *\n     * Because of the near-symmetry of requesting hasPreviousPage vs\n     * hasNextPage we always pretend we're determining `hasNextPage`, and we\n     * just invert everything.\n     */\n\n    const sqlCommonUnbounded = sql.fragment`\\\nselect 1\nfrom ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}`;\n    /*\n     * This variable is a fragment to go into an `EXISTS(...)` call (after some tweaks).\n     *\n     * The buildWhereClause takes three arguments:\n     *\n     * - includeLowerBound (we want this for hasNextPage but not hasPreviousPage)\n     * - includeUpperBound (we want this for hasPreviousPage but not hasNextPage)\n     * - options (specifically `{addNullCase, addNotDistinctFromNullCase}`) -\n     *   we just pass this through.\n     *\n     * So in hasNextPage mode (invert === false), this common SQL ends up\n     * representing the collection from `(after || START)` onwards with no\n     * upper bound. In hasPreviousPage mode (invert === true), it represents\n     * everything from `(before || END)` backwards, with no lower bound.\n     */\n    const sqlCommon = sql.fragment`\\\n${sqlCommonUnbounded}\nwhere ${queryBuilder.buildWhereClause(!invert, invert, options)}`;\n\n    /*\n     * Since the offset makes the diagram asymmetric, if offset === 0\n     * then the diagram is symmetric and things are simplified a little.\n     */\n    const isForwardOrSymmetric = !invert || offset === 0;\n\n    if (!isForwardOrSymmetric) {\n      assert(invert);\n      assert(offset > 0);\n      // We're looking for a previous page, and there's an offset, so lets just\n      // assume there's a previous page where offset is smaller.\n      return sql.literal(true);\n    } else if (canHaveCursorInWhere) {\n      assert(isForwardOrSymmetric);\n      if (!queryHasBefore && !queryHasFirst) {\n        assert(isForwardOrSymmetric);\n        // There can be no next page since there's no upper bound\n        return sql.literal(false);\n      } else if (queryHasBefore && !queryHasFirst) {\n        /*\n         * We invert the upper buildWhereBoundClause to only represent the data\n         * after `before`, then check if there's at least one record in that set.\n         *\n         * This only works if the `before` cursor can be represented in the\n         * SQL WHERE clause, otherwise we're doing limit/offset pagination\n         * which requires different logic. It also only works if there's no\n         * `first` clause, otherwise there could be a next page before the\n         * `before` clause.\n         */\n        return sql.fragment`\\\nexists(\n  ${sqlCommonUnbounded}\n  where ${queryBuilder.buildWhereClause(false, false, options)}\n  and not (${queryBuilder.buildWhereBoundClause(invert)})\n)`;\n      } else {\n        assert(queryHasFirst);\n        // queryHasBefore could be true or false.\n        /*\n         * There's a few ways that we could determine if there's a next page.\n         *\n         * If !queryHasBefore, we could COUNT(*) the number of rows in\n         * `sqlCommon` and see if it's larger than `first`:\n         * `(select count(*) > ${first} from (${sqlCommon}) __random_table_alias__)`\n         *\n         * If !queryHasBefore, we could build a subquery table of offsetData\n         * from sqlCommon and see if it contains any rows:\n         * `EXISTS(select 1 from (${sqlCommon} OFFSET ${first}) __random_table_alias__)`.\n         *\n         * We could see if there's at least one row in sqlCommon that's not\n         * already in our chosen result set.\n         *\n         * We've chosen the latter approach here because it doesn't place a limit\n         * on queryHasBefore.\n         */\n        // Drop the `first` limit, see if there are any records that aren't\n        // already in the list we've fetched.\n        return sql.fragment`\\\nexists(\n  ${sqlCommon}\n  and (${queryBuilder.getSelectCursor()})::text not in (select __cursor::text from ${sqlQueryAlias})\n  ${offset === 0 ? sql.blank : sql.fragment`offset ${sql.value(offset)}`}\n)`;\n      }\n    } else {\n      assert(!invert || offset === 0); // isForwardOrSymmetric\n      assert(!canHaveCursorInWhere);\n      // We're dealing with LIMIT/OFFSET pagination here, which means `natural`\n      // cursors, so the `queryBuilder` factors the before/after, first/last\n      // into the limit / offset.\n      const { limit } = queryBuilder.getFinalLimitAndOffset();\n\n      if (limit == null) {\n        // If paginating backwards, then offset > 0 has already been dealt\n        // with. Unbounded, so there's no next page.\n        return sql.fragment`false`;\n      } else if (invert) {\n        assert(offset === 0);\n        // Paginating backwards and there's no offset (which factors in before/after), so there's no previous page.\n        return sql.fragment`false`;\n      } else {\n        assert(!invert);\n        /*\n         * We're paginating forwards; either there's a before, there's a first,\n         * or both.\n         *\n         * We want to see if there's more than limit+offset records in sqlCommon.\n         */\n        return sql.fragment`\\\nexists(\n  ${sqlCommon}\n  offset ${sql.literal(limit + offset)}\n)`;\n      }\n    }\n  }\n  const getPgCursorPrefix = () =>\n    rawCursorPrefix && rawCursorPrefix.length > 0\n      ? rawCursorPrefix\n      : queryBuilder.data.cursorPrefix.map(val => sql.literal(val));\n  if (\n    options.withPagination ||\n    options.withPaginationAsFields ||\n    options.withCursor\n  ) {\n    // Sometimes we need a __cursor even if it's not a collection; e.g. to get the edge field on a mutation\n    if (usesCursor) {\n      queryBuilder.selectCursor(() => {\n        const orderBy = queryBuilder\n          .getOrderByExpressionsAndDirections()\n          .map(([expr]) => expr);\n        if (queryBuilder.isOrderUnique() && orderBy.length > 0) {\n          return sql.fragment`json_build_array(${sql.join(\n            [\n              ...getPgCursorPrefix(),\n              sql.fragment`json_build_array(${sql.join(orderBy, \", \")})`,\n            ],\n            \", \"\n          )})`;\n        } else {\n          return sql.fragment`json_build_array(${sql.join(\n            getPgCursorPrefix(),\n            \", \"\n          )}, (row_number() over (partition by 1)))`;\n        }\n      });\n    }\n  }\n  if (options.withPagination || options.withPaginationAsFields) {\n    queryBuilder.setCursorComparator((cursorValue, isAfter) => {\n      const orderByExpressionsAndDirections = queryBuilder.getOrderByExpressionsAndDirections();\n      if (\n        orderByExpressionsAndDirections.length > 0 &&\n        queryBuilder.isOrderUnique()\n      ) {\n        const sqlCursors = cursorValue[getPgCursorPrefix().length].map(val =>\n          sql.value(val)\n        );\n        if (!Array.isArray(sqlCursors)) {\n          queryBuilder.whereBound(sql.literal(false), isAfter);\n        }\n        let sqlFilter = sql.fragment`false`;\n        for (let i = orderByExpressionsAndDirections.length - 1; i >= 0; i--) {\n          const [sqlExpression, ascending] = orderByExpressionsAndDirections[i];\n          // If ascending and isAfter then >\n          // If ascending and isBefore then <\n          const comparison =\n            Number(ascending) ^ Number(!isAfter)\n              ? sql.fragment`>`\n              : sql.fragment`<`;\n\n          const sqlOldFilter = sqlFilter;\n          sqlFilter = sql.fragment`\\\n(\\\n  (${sqlExpression} ${comparison} ${sqlCursors[i] || sql.null})\nOR\\\n  (\\\n    ${sqlExpression} = ${sqlCursors[i] || sql.null}\\\n  AND\\\n    ${sqlOldFilter}\\\n  )\\\n)`;\n        }\n        queryBuilder.whereBound(sqlFilter, isAfter);\n      } else if (\n        cursorValue[0] === \"natural\" &&\n        isSafeInteger(cursorValue[1]) &&\n        cursorValue[1] >= 0\n      ) {\n        if (isAfter) {\n          queryBuilder.offset(() => cursorValue[1]);\n        } else {\n          queryBuilder.limit(() => {\n            const offset = queryBuilder.getOffset();\n            return Math.max(0, cursorValue[1] - offset - 1);\n          });\n        }\n      } else {\n        throw new Error(\"Cannot use cursors without orderBy\");\n      }\n    });\n\n    const query = queryBuilder.build(options);\n    const haveFields = queryBuilder.getSelectFieldsCount() > 0;\n    const sqlQueryAlias = sql.identifier(Symbol());\n    const sqlSummaryAlias = sql.identifier(Symbol());\n    //\n    // Tables should ALWAYS push their PK onto the order stack, if this isn't\n    // present then we're either dealing with a view or a table without a PK.\n    // Either way, we don't have anything to guarantee uniqueness so we need to\n    // fall back to limit/offset.\n    //\n    // TODO: support unique keys in PgAllRows etc\n    // TODO: add a warning for cursor-based pagination when using the fallback\n    // TODO: if it is a view maybe add a warning encouraging pgViewUniqueKey\n    const canHaveCursorInWhere =\n      queryBuilder.getOrderByExpressionsAndDirections().length > 0 &&\n      queryBuilder.isOrderUnique();\n    const queryHasBefore =\n      queryBuilder.compiledData.whereBound.upper.length > 0;\n    const queryHasAfter = queryBuilder.compiledData.whereBound.lower.length > 0;\n    const queryHasZeroLimit = queryBuilder.getFinalLimit() === 0;\n    const queryHasFirst = isSafeInteger(queryBuilder.compiledData.first);\n    const queryHasLast = isSafeInteger(queryBuilder.compiledData.last);\n    const hasNextPage = queryHasZeroLimit\n      ? sql.literal(false)\n      : generateNextPrevPageSql(\n          sqlQueryAlias,\n          canHaveCursorInWhere,\n          queryHasBefore,\n          queryHasFirst,\n          queryBuilder.getFinalOffset() || 0\n        );\n    const hasPreviousPage = queryHasZeroLimit\n      ? sql.literal(false)\n      : generateNextPrevPageSql(\n          sqlQueryAlias,\n          canHaveCursorInWhere,\n          queryHasAfter,\n          queryHasLast,\n          queryBuilder.getFinalOffset() || 0,\n          true\n        );\n\n    const sqlWith = haveFields\n      ? sql.fragment`with ${sqlQueryAlias} as (${query}), ${sqlSummaryAlias} as (select json_agg(to_json(${sqlQueryAlias})) as data from ${sqlQueryAlias})`\n      : sql.fragment``;\n    const sqlFrom = sql.fragment``;\n    const fields: Array<[SQL, RawAlias]> = [];\n    if (haveFields) {\n      fields.push([\n        sql.fragment`coalesce((select ${sqlSummaryAlias}.data from ${sqlSummaryAlias}), '[]'::json)`,\n        \"data\",\n      ]);\n      if (calculateHasNextPage) {\n        fields.push([hasNextPage, \"hasNextPage\"]);\n      }\n      if (calculateHasPreviousPage) {\n        fields.push([hasPreviousPage, \"hasPreviousPage\"]);\n      }\n    }\n    if (pgAggregateQuery && pgAggregateQuery.length) {\n      const aggregateQueryBuilder = new QueryBuilder(\n        // $FlowFixMe\n        queryBuilderOptions,\n        context,\n        rootValue\n      );\n      aggregateQueryBuilder.from(\n        queryBuilder.getTableExpression(),\n        queryBuilder.getTableAlias()\n      );\n\n      for (let i = 0, l = pgAggregateQuery.length; i < l; i++) {\n        pgAggregateQuery[i](aggregateQueryBuilder);\n      }\n      const aggregateJsonBuildObject = aggregateQueryBuilder.build({\n        onlyJsonField: true,\n      });\n      const aggregatesSql = sql.fragment`\\\n(\n  select ${aggregateJsonBuildObject}\n  from ${queryBuilder.getTableExpression()} as ${queryBuilder.getTableAlias()}\n  where ${queryBuilder.buildWhereClause(false, false, options)}\n)`;\n      fields.push([aggregatesSql, \"aggregates\"]);\n    }\n    if (options.withPaginationAsFields) {\n      return sql.fragment`${sqlWith} select ${sql.join(\n        fields.map(\n          ([expr, alias]) => sql.fragment`${expr} as ${sql.identifier(alias)}`\n        ),\n        \", \"\n      )} ${sqlFrom}`;\n    } else {\n      return sql.fragment`${sqlWith} select ${queryBuilder.jsonbBuildObject(\n        fields\n      )} ${sqlFrom}`;\n    }\n  } else {\n    const query = queryBuilder.build(options);\n    return query;\n  }\n};\n"],"file":"queryFromResolveDataFactory.js"}